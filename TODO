miscellaeny
-----------
- MACROEXPAND
- everything in ::Rouge should be accessible via rouge.builtin
- organise boot.rg
- test the whole core
- omit Ruby from tracebacks?
- better read errors
- better exceptions/errors
- readline autocomplete
- package as a gem?

ruby interop
------------
- accessing the scope/self (DSLs!)
- proc or lambda? setting ARITY.
  - DEFN/DEFMACRO/etc. should create strict lambdas, but FN/#() should not.

"hard" tasks
------------
- have a core "apply" function which can be used by eval, defmacro, etc.
- re-org to allow "compilation" phase: (defmacro a [] b) without a "b" in context should fail immediately.
  - probably generic walking would be nice here
  - macro interpretation in one pass before regular evaluation: this would effect the desired outcome, I think?

core lang
---------
- vars
- dynamic/special vars
- interning, vars, ...
- symbols should have two distinct parts: ns, name
- multi-form defn: (defn x ([a] ...) ([a b] ...))
- seqs
  - atoms, refs, agents
- freeze vectors, lists where approriate
- (. x y)
- destructuring (in FN, LET, everywhere else)
- rest of the clojure core API (maybe even in clojure.core ns)
- clojure-ish IO libraries which expose async IO
- defprotocol -- looks important! ISeq, ISeqable, ISequential and what have you.
- metadata on all collections (not just symbols)
